/**
 *
 * This wait command is your universal weapon if you want to wait on
 * something. It expects a condition and waits until that condition
 * is fulfilled with an truthy value. A condition can be either a promise
 * or a command that returns a promise.
 *
 * A common example is to wait until a certain element contains a certain
 * text.
 *
 * <example>
    :example.html
    <div id="someText">I am some text</div>
    <script>
      setTimeout(function() {
        $('#someText').html('I am now different');
      }, 1000);
    </script>

    :waitUntil.js
    client.waitUntil(function() {
      return this.getText('#someText').then(function(text) {
        return text === 'I am now different'
      });
    });
 * </example>
 *
 *
 * @param {Function|Promise} condition  condition to wait on
 * @param {Number=}          ms         timeout in ms (default: 500)
 *
 * @uses utility/pause
 * @type utility
 *
 */

'use strict';

var _Promise = require('babel-runtime/core-js/promise')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsErrorHandler = require('../utils/ErrorHandler');

var REJECT_MESSAGE = 'Promise never resolved with an truthy value';

var waitUntil = function waitUntil(condition, ms) {
    var _this = this;

    var starttime = arguments.length <= 2 || arguments[2] === undefined ? new Date().getTime() : arguments[2];

    var promise = undefined;

    /*!
     * ensure that ms is set properly
     */
    if (typeof ms !== 'number') {
        ms = this.options.waitforTimeout;
    }

    if (typeof condition === 'function') {
        promise = condition.call(this);
    } else {
        promise = _Promise.resolve(condition);
    }

    var now = new Date().getTime();
    var timeLeft = ms - (now - starttime);
    timeLeft = timeLeft < 0 ? 0 : timeLeft;

    if (!timeLeft) {
        return _Promise.reject(new _utilsErrorHandler.CommandError(REJECT_MESSAGE));
    }

    return new _Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
            reject(new _utilsErrorHandler.CommandError(REJECT_MESSAGE));
        }, timeLeft < 0 ? 0 : timeLeft);

        promise.then(function (res) {
            clearTimeout(timeout);

            if (!res) {
                return resolve(_this.pause(250).waitUntil(condition, ms, starttime));
            }

            resolve(res);
        }, function (err) {
            clearTimeout(timeout);
            reject(new _utilsErrorHandler.CommandError('Promise was fulfilled but got rejected with the following reason: ' + err));
        });
    });
};

exports['default'] = waitUntil;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jb21tYW5kcy93YWl0VW50aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBb0M2Qix1QkFBdUI7O0FBRXBELElBQU0sY0FBYyxHQUFHLDZDQUE2QyxDQUFBOztBQUVwRSxJQUFJLFNBQVMsR0FBRyxTQUFaLFNBQVMsQ0FBYSxTQUFTLEVBQUUsRUFBRSxFQUFvQzs7O1FBQWxDLFNBQVMseURBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUU7O0FBQ3JFLFFBQUksT0FBTyxZQUFBLENBQUE7Ozs7O0FBS1gsUUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQUU7QUFDeEIsVUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFBO0tBQ25DOztBQUVELFFBQUksT0FBTyxTQUFTLEtBQUssVUFBVSxFQUFFO0FBQ2pDLGVBQU8sR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0tBQ2pDLE1BQU07QUFDSCxlQUFPLEdBQUcsU0FBUSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUE7S0FDdkM7O0FBRUQsUUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtBQUM5QixRQUFJLFFBQVEsR0FBRyxFQUFFLElBQUksR0FBRyxHQUFHLFNBQVMsQ0FBQSxBQUFDLENBQUE7QUFDckMsWUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQTs7QUFFdEMsUUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNYLGVBQU8sU0FBUSxNQUFNLENBQUMsb0NBQWlCLGNBQWMsQ0FBQyxDQUFDLENBQUE7S0FDMUQ7O0FBRUQsV0FBTyxhQUFZLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUNwQyxZQUFJLE9BQU8sR0FBRyxVQUFVLENBQUMsWUFBTTtBQUMzQixrQkFBTSxDQUFDLG9DQUFpQixjQUFjLENBQUMsQ0FBQyxDQUFBO1NBQzNDLEVBQUUsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUE7O0FBRS9CLGVBQU8sQ0FBQyxJQUFJLENBQUMsVUFBQyxHQUFHLEVBQUs7QUFDbEIsd0JBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQTs7QUFFckIsZ0JBQUksQ0FBQyxHQUFHLEVBQUU7QUFDTix1QkFBTyxPQUFPLENBQUMsTUFBSyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQTthQUN0RTs7QUFFRCxtQkFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1NBQ2YsRUFBRSxVQUFDLEdBQUcsRUFBSztBQUNSLHdCQUFZLENBQUMsT0FBTyxDQUFDLENBQUE7QUFDckIsa0JBQU0sQ0FBQywyR0FBc0YsR0FBRyxDQUFHLENBQUMsQ0FBQTtTQUN2RyxDQUFDLENBQUE7S0FDTCxDQUFDLENBQUE7Q0FDTCxDQUFBOztxQkFFYyxTQUFTIiwiZmlsZSI6IndhaXRVbnRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIFRoaXMgd2FpdCBjb21tYW5kIGlzIHlvdXIgdW5pdmVyc2FsIHdlYXBvbiBpZiB5b3Ugd2FudCB0byB3YWl0IG9uXG4gKiBzb21ldGhpbmcuIEl0IGV4cGVjdHMgYSBjb25kaXRpb24gYW5kIHdhaXRzIHVudGlsIHRoYXQgY29uZGl0aW9uXG4gKiBpcyBmdWxmaWxsZWQgd2l0aCBhbiB0cnV0aHkgdmFsdWUuIEEgY29uZGl0aW9uIGNhbiBiZSBlaXRoZXIgYSBwcm9taXNlXG4gKiBvciBhIGNvbW1hbmQgdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiBBIGNvbW1vbiBleGFtcGxlIGlzIHRvIHdhaXQgdW50aWwgYSBjZXJ0YWluIGVsZW1lbnQgY29udGFpbnMgYSBjZXJ0YWluXG4gKiB0ZXh0LlxuICpcbiAqIDxleGFtcGxlPlxuICAgIDpleGFtcGxlLmh0bWxcbiAgICA8ZGl2IGlkPVwic29tZVRleHRcIj5JIGFtIHNvbWUgdGV4dDwvZGl2PlxuICAgIDxzY3JpcHQ+XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkKCcjc29tZVRleHQnKS5odG1sKCdJIGFtIG5vdyBkaWZmZXJlbnQnKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIDwvc2NyaXB0PlxuXG4gICAgOndhaXRVbnRpbC5qc1xuICAgIGNsaWVudC53YWl0VW50aWwoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCcjc29tZVRleHQnKS50aGVuKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQgPT09ICdJIGFtIG5vdyBkaWZmZXJlbnQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxQcm9taXNlfSBjb25kaXRpb24gIGNvbmRpdGlvbiB0byB3YWl0IG9uXG4gKiBAcGFyYW0ge051bWJlcj19ICAgICAgICAgIG1zICAgICAgICAgdGltZW91dCBpbiBtcyAoZGVmYXVsdDogNTAwKVxuICpcbiAqIEB1c2VzIHV0aWxpdHkvcGF1c2VcbiAqIEB0eXBlIHV0aWxpdHlcbiAqXG4gKi9cblxuaW1wb3J0IHsgQ29tbWFuZEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvRXJyb3JIYW5kbGVyJ1xuXG5jb25zdCBSRUpFQ1RfTUVTU0FHRSA9ICdQcm9taXNlIG5ldmVyIHJlc29sdmVkIHdpdGggYW4gdHJ1dGh5IHZhbHVlJ1xuXG5sZXQgd2FpdFVudGlsID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgbXMsIHN0YXJ0dGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgbGV0IHByb21pc2VcblxuICAgIC8qIVxuICAgICAqIGVuc3VyZSB0aGF0IG1zIGlzIHNldCBwcm9wZXJseVxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgbXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIG1zID0gdGhpcy5vcHRpb25zLndhaXRmb3JUaW1lb3V0XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25kaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZSA9IGNvbmRpdGlvbi5jYWxsKHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25kaXRpb24pXG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgdmFyIHRpbWVMZWZ0ID0gbXMgLSAobm93IC0gc3RhcnR0aW1lKVxuICAgIHRpbWVMZWZ0ID0gdGltZUxlZnQgPCAwID8gMCA6IHRpbWVMZWZ0XG5cbiAgICBpZiAoIXRpbWVMZWZ0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQ29tbWFuZEVycm9yKFJFSkVDVF9NRVNTQUdFKSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb21tYW5kRXJyb3IoUkVKRUNUX01FU1NBR0UpKVxuICAgICAgICB9LCB0aW1lTGVmdCA8IDAgPyAwIDogdGltZUxlZnQpXG5cbiAgICAgICAgcHJvbWlzZS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuXG4gICAgICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMucGF1c2UoMjUwKS53YWl0VW50aWwoY29uZGl0aW9uLCBtcywgc3RhcnR0aW1lKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpXG4gICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb21tYW5kRXJyb3IoYFByb21pc2Ugd2FzIGZ1bGZpbGxlZCBidXQgZ290IHJlamVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyByZWFzb246ICR7ZXJyfWApKVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhaXRVbnRpbFxuIl19
