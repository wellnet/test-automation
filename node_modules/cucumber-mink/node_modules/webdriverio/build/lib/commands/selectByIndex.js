/**
 *
 * Select option with a specific index.
 *
 * <example>
    :example.html
    <select id="selectbox">
        <option value="someValue0">uno</option>
        <option value="someValue1">dos</option>
        <option value="someValue2">tres</option>
        <option value="someValue3">cuatro</option>
        <option value="someValue4">cinco</option>
        <option value="someValue5">seis</option>
    </select>

    :selectByIndex.js
    client
        .getValue('#selectbox')
        .then(function(value) {
            console.log(value);
            // returns "someValue0"
        })
        .selectByIndex('#selectbox', 4)
        .getValue('#selectbox')
        .then(function(value) {
            console.log(value);
            // returns "someValue4"
        });
 * </example>
 *
 * @param {String} selectElem select element that contains the options
 * @param {Number} index      option index
 *
 * @uses protocol/element, protocol/elementIdElements, protocol/elementIdClick
 * @type action
 *
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsErrorHandler = require('../utils/ErrorHandler');

var selectByIndex = function selectByIndex(selectElem, index) {
    var _this = this;

    /*!
     * parameter check
     */
    if (typeof selectElem !== 'string' || typeof index !== 'number') {
        throw new _utilsErrorHandler.CommandError('number or type of arguments don\'t agree with selectByIndex command');
    }

    /*!
     * negative index check
     */
    if (index < 0) {
        throw new _utilsErrorHandler.CommandError('index needs to be 0 or any other positive number');
    }

    return this.element(selectElem).then(function (element) {
        return _this.elementIdElements(element.value.ELEMENT, '<option>');
    }).then(function (elements) {
        if (elements.value.length === 0) {
            throw new _utilsErrorHandler.CommandError('select element (' + selectElem + ') doesn\'t contain any option element');
        }
        if (elements.value.length - 1 < index) {
            throw new _utilsErrorHandler.CommandError('option with index "' + index + '" not found. Select element (' + selectElem + ') only contains ' + elements.value.length + ' option elements');
        }

        return _this.elementIdClick(elements.value[index].ELEMENT);
    });
};

exports['default'] = selectByIndex;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9jb21tYW5kcy9zZWxlY3RCeUluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQXNDNkIsdUJBQXVCOztBQUVwRCxJQUFJLGFBQWEsR0FBRyxTQUFoQixhQUFhLENBQWEsVUFBVSxFQUFFLEtBQUssRUFBRTs7Ozs7O0FBSTdDLFFBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3RCxjQUFNLG9DQUFpQixxRUFBcUUsQ0FBQyxDQUFBO0tBQ2hHOzs7OztBQUtELFFBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtBQUNYLGNBQU0sb0NBQWlCLGtEQUFrRCxDQUFDLENBQUE7S0FDN0U7O0FBRUQsV0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUMxQixJQUFJLENBQUMsVUFBQyxPQUFPO2VBQUssTUFBSyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUM7S0FBQSxDQUFDLENBQzVFLElBQUksQ0FBQyxVQUFDLFFBQVEsRUFBSztBQUNoQixZQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUM3QixrQkFBTSx5REFBb0MsVUFBVSwyQ0FBdUMsQ0FBQTtTQUM5RjtBQUNELFlBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEtBQUssRUFBRTtBQUNuQyxrQkFBTSw0REFBdUMsS0FBSyxxQ0FBZ0MsVUFBVSx3QkFBbUIsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLHNCQUFtQixDQUFBO1NBQzFKOztBQUVELGVBQU8sTUFBSyxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQTtLQUM1RCxDQUFDLENBQUE7Q0FDVCxDQUFBOztxQkFFYyxhQUFhIiwiZmlsZSI6InNlbGVjdEJ5SW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBTZWxlY3Qgb3B0aW9uIHdpdGggYSBzcGVjaWZpYyBpbmRleC5cbiAqXG4gKiA8ZXhhbXBsZT5cbiAgICA6ZXhhbXBsZS5odG1sXG4gICAgPHNlbGVjdCBpZD1cInNlbGVjdGJveFwiPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwic29tZVZhbHVlMFwiPnVubzwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwic29tZVZhbHVlMVwiPmRvczwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwic29tZVZhbHVlMlwiPnRyZXM8L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbWVWYWx1ZTNcIj5jdWF0cm88L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbWVWYWx1ZTRcIj5jaW5jbzwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwic29tZVZhbHVlNVwiPnNlaXM8L29wdGlvbj5cbiAgICA8L3NlbGVjdD5cblxuICAgIDpzZWxlY3RCeUluZGV4LmpzXG4gICAgY2xpZW50XG4gICAgICAgIC5nZXRWYWx1ZSgnI3NlbGVjdGJveCcpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIFwic29tZVZhbHVlMFwiXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RCeUluZGV4KCcjc2VsZWN0Ym94JywgNClcbiAgICAgICAgLmdldFZhbHVlKCcjc2VsZWN0Ym94JylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgXCJzb21lVmFsdWU0XCJcbiAgICAgICAgfSk7XG4gKiA8L2V4YW1wbGU+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdEVsZW0gc2VsZWN0IGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgb3B0aW9uIGluZGV4XG4gKlxuICogQHVzZXMgcHJvdG9jb2wvZWxlbWVudCwgcHJvdG9jb2wvZWxlbWVudElkRWxlbWVudHMsIHByb3RvY29sL2VsZW1lbnRJZENsaWNrXG4gKiBAdHlwZSBhY3Rpb25cbiAqXG4gKi9cblxuaW1wb3J0IHsgQ29tbWFuZEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvRXJyb3JIYW5kbGVyJ1xuXG5sZXQgc2VsZWN0QnlJbmRleCA9IGZ1bmN0aW9uIChzZWxlY3RFbGVtLCBpbmRleCkge1xuICAgIC8qIVxuICAgICAqIHBhcmFtZXRlciBjaGVja1xuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0RWxlbSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgQ29tbWFuZEVycm9yKCdudW1iZXIgb3IgdHlwZSBvZiBhcmd1bWVudHMgZG9uXFwndCBhZ3JlZSB3aXRoIHNlbGVjdEJ5SW5kZXggY29tbWFuZCcpXG4gICAgfVxuXG4gICAgLyohXG4gICAgICogbmVnYXRpdmUgaW5kZXggY2hlY2tcbiAgICAgKi9cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBDb21tYW5kRXJyb3IoJ2luZGV4IG5lZWRzIHRvIGJlIDAgb3IgYW55IG90aGVyIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudChzZWxlY3RFbGVtKVxuICAgICAgICAudGhlbigoZWxlbWVudCkgPT4gdGhpcy5lbGVtZW50SWRFbGVtZW50cyhlbGVtZW50LnZhbHVlLkVMRU1FTlQsICc8b3B0aW9uPicpKVxuICAgICAgICAudGhlbigoZWxlbWVudHMpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29tbWFuZEVycm9yKGBzZWxlY3QgZWxlbWVudCAoJHtzZWxlY3RFbGVtfSkgZG9lc24ndCBjb250YWluIGFueSBvcHRpb24gZWxlbWVudGApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMudmFsdWUubGVuZ3RoIC0gMSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbW1hbmRFcnJvcihgb3B0aW9uIHdpdGggaW5kZXggXCIke2luZGV4fVwiIG5vdCBmb3VuZC4gU2VsZWN0IGVsZW1lbnQgKCR7c2VsZWN0RWxlbX0pIG9ubHkgY29udGFpbnMgJHtlbGVtZW50cy52YWx1ZS5sZW5ndGh9IG9wdGlvbiBlbGVtZW50c2ApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRJZENsaWNrKGVsZW1lbnRzLnZhbHVlW2luZGV4XS5FTEVNRU5UKVxuICAgICAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBzZWxlY3RCeUluZGV4XG4iXX0=
