/**
 * Scroll on the touch screen using finger based motion events. If
 * element ID is given start scrolling at a particular screen location.
 *
 * @param {String} id       the element where the scroll starts.
 * @param {Number} xoffset  in pixels to scroll by
 * @param {Number} yoffset  in pixels to scroll by
 *
 * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol#session/:sessionId/touch/scroll
 * @type protocol
 *
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _utilsErrorHandler = require('../utils/ErrorHandler');

var touchScroll = function touchScroll(id, xoffset, yoffset) {
    var data = {};

    /*!
     * start scrolling at a particular screen location
     */
    if (arguments.length === 3 && id && typeof xoffset === 'number' && typeof yoffset === 'number') {
        data = { element: id, xoffset: xoffset, yoffset: yoffset };

        /*!
         * if you don't care where the scroll starts on the screen
         */
    } else if (arguments.length === 3 && !id && typeof xoffset === 'number' && typeof yoffset === 'number') {
            data = { xoffset: xoffset, yoffset: yoffset };

            /*!
             * if you don't care where the scroll starts on the screen
             */
        } else if (arguments.length === 2 && typeof id === 'number' && typeof xoffset === 'number') {
                data = {
                    xoffset: id,
                    yoffset: xoffset
                };
            } else {
                throw new _utilsErrorHandler.ProtocolError('number or type of arguments don\'t agree with touchScroll command');
            }

    return this.requestHandler.create('/session/:sessionId/touch/scroll', data);
};

exports['default'] = touchScroll;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9wcm90b2NvbC90b3VjaFNjcm9sbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQWE4Qix1QkFBdUI7O0FBRXJELElBQUksV0FBVyxHQUFHLFNBQWQsV0FBVyxDQUFhLEVBQUUsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQzlDLFFBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQTs7Ozs7QUFLYixRQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzVGLFlBQUksR0FBRyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFQLE9BQU8sRUFBRSxPQUFPLEVBQVAsT0FBTyxFQUFFLENBQUE7Ozs7O0tBSzNDLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQ3BHLGdCQUFJLEdBQUcsRUFBRSxPQUFPLEVBQVAsT0FBTyxFQUFFLE9BQU8sRUFBUCxPQUFPLEVBQUUsQ0FBQTs7Ozs7U0FLOUIsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLE9BQU8sRUFBRSxLQUFLLFFBQVEsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7QUFDeEYsb0JBQUksR0FBRztBQUNILDJCQUFPLEVBQUUsRUFBRTtBQUNYLDJCQUFPLEVBQUUsT0FBTztpQkFDbkIsQ0FBQTthQUNKLE1BQU07QUFDSCxzQkFBTSxxQ0FBa0IsbUVBQW1FLENBQUMsQ0FBQTthQUMvRjs7QUFFRCxXQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFLElBQUksQ0FBQyxDQUFBO0NBQzlFLENBQUE7O3FCQUVjLFdBQVciLCJmaWxlIjoidG91Y2hTY3JvbGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNjcm9sbCBvbiB0aGUgdG91Y2ggc2NyZWVuIHVzaW5nIGZpbmdlciBiYXNlZCBtb3Rpb24gZXZlbnRzLiBJZlxuICogZWxlbWVudCBJRCBpcyBnaXZlbiBzdGFydCBzY3JvbGxpbmcgYXQgYSBwYXJ0aWN1bGFyIHNjcmVlbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgICAgICAgdGhlIGVsZW1lbnQgd2hlcmUgdGhlIHNjcm9sbCBzdGFydHMuXG4gKiBAcGFyYW0ge051bWJlcn0geG9mZnNldCAgaW4gcGl4ZWxzIHRvIHNjcm9sbCBieVxuICogQHBhcmFtIHtOdW1iZXJ9IHlvZmZzZXQgIGluIHBpeGVscyB0byBzY3JvbGwgYnlcbiAqXG4gKiBAc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9zZWxlbml1bS93aWtpL0pzb25XaXJlUHJvdG9jb2wjc2Vzc2lvbi86c2Vzc2lvbklkL3RvdWNoL3Njcm9sbFxuICogQHR5cGUgcHJvdG9jb2xcbiAqXG4gKi9cblxuaW1wb3J0IHsgUHJvdG9jb2xFcnJvciB9IGZyb20gJy4uL3V0aWxzL0Vycm9ySGFuZGxlcidcblxubGV0IHRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKGlkLCB4b2Zmc2V0LCB5b2Zmc2V0KSB7XG4gICAgbGV0IGRhdGEgPSB7fVxuXG4gICAgLyohXG4gICAgICogc3RhcnQgc2Nyb2xsaW5nIGF0IGEgcGFydGljdWxhciBzY3JlZW4gbG9jYXRpb25cbiAgICAgKi9cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiBpZCAmJiB0eXBlb2YgeG9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEgPSB7IGVsZW1lbnQ6IGlkLCB4b2Zmc2V0LCB5b2Zmc2V0IH1cblxuICAgIC8qIVxuICAgICAqIGlmIHlvdSBkb24ndCBjYXJlIHdoZXJlIHRoZSBzY3JvbGwgc3RhcnRzIG9uIHRoZSBzY3JlZW5cbiAgICAgKi9cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlkICYmIHR5cGVvZiB4b2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeW9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YSA9IHsgeG9mZnNldCwgeW9mZnNldCB9XG5cbiAgICAvKiFcbiAgICAgKiBpZiB5b3UgZG9uJ3QgY2FyZSB3aGVyZSB0aGUgc2Nyb2xsIHN0YXJ0cyBvbiB0aGUgc2NyZWVuXG4gICAgICovXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHhvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICB4b2Zmc2V0OiBpZCxcbiAgICAgICAgICAgIHlvZmZzZXQ6IHhvZmZzZXRcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQcm90b2NvbEVycm9yKCdudW1iZXIgb3IgdHlwZSBvZiBhcmd1bWVudHMgZG9uXFwndCBhZ3JlZSB3aXRoIHRvdWNoU2Nyb2xsIGNvbW1hbmQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlcXVlc3RIYW5kbGVyLmNyZWF0ZSgnL3Nlc3Npb24vOnNlc3Npb25JZC90b3VjaC9zY3JvbGwnLCBkYXRhKVxufVxuXG5leHBvcnQgZGVmYXVsdCB0b3VjaFNjcm9sbFxuIl19
